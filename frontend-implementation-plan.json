{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Fix drag-and-drop into non-empty lists",
  "requirements": [
    {
      "id": "REQ-1",
      "summary": "Fix the drop handler in CustomLists so that when a task is dragged into a list that already contains tasks, the 1000-based order value is correctly calculated between the two neighbor tasks at the drop position",
      "acceptanceCriteria": [
        "Dragging a task into a non-empty list moves it to the correct visual position immediately (optimistic UI).",
        "The calculated order value places the task between its new neighbors using the 1000-based method without requiring recalculation of other tasks.",
        "Dropping at the top of a non-empty list assigns an order less than the first task's order.",
        "Dropping at the bottom of a non-empty list assigns an order greater than the last task's order.",
        "Dropping between two tasks assigns an order between their two order values."
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/CustomLists.tsx",
          "operation": "modify",
          "description": "Fix the drop handler's order calculation logic for non-empty destination lists. When dropping at index 0 (top), calculate order as (firstTask.order - 1000). When dropping at the end, calculate order as (lastTask.order + 1000). When dropping between tasks at index i, calculate order as ((tasks[i-1].order + tasks[i].order) / 2). Ensure BigInt arithmetic is used consistently. Remove any conditional branches that skip order calculation for non-empty lists. Verify the existing drag payload reading from dataTransfer works correctly for non-empty list drops."
        }
      ]
    },
    {
      "id": "REQ-2",
      "summary": "Fix the optimistic local state update in the drop handler so that when a task is dropped into a non-empty destination list, both the task's listId and new order are immediately applied to local React state",
      "acceptanceCriteria": [
        "On drop, the task instantly moves to the destination list in the UI with the correct order, even before the backend responds.",
        "The source list no longer shows the task immediately after drop.",
        "If the backend call fails, the task reverts to its original list and position (pre-drag snapshot rollback).",
        "Empty-list drag-and-drop continues to work as before."
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/CustomLists.tsx",
          "operation": "modify",
          "description": "Fix the optimistic state update in the drop handler to immediately apply both the new listId and computed order to the dragged task in the local tasks state. Ensure the queryClient.setQueryData call for ['tasks'] updates the task object with { ...task, listId: destinationListId, order: calculatedOrder } before the backend mutation is called. Verify that the source list immediately reflects the task removal and the destination list immediately shows the task at the correct position. Ensure the pre-drag snapshot (stored at dragStart) is used for rollback on backend failure. Test that empty-list drops still function correctly after this change."
        }
      ]
    },
    {
      "id": "REQ-3",
      "summary": "Ensure the backend updateTask call is invoked with the updated listId and order after a successful optimistic update into a non-empty list, and that a failure triggers a full rollback to the pre-drag snapshot",
      "acceptanceCriteria": [
        "Backend is called with the new listId and computed order after every successful drop into a non-empty list.",
        "On backend error, all affected local state is restored to the snapshot taken at drag start.",
        "A toast or error indicator is shown if the backend sync fails."
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/CustomLists.tsx",
          "operation": "modify",
          "description": "Ensure the updateTask mutation (from useUpdateTask hook) is called with the full TaskUpdateInput including the new listId and computed order immediately after the optimistic state update. Wrap the mutation call in a try-catch block. On error, restore the queryClient tasks state to the pre-drag snapshot and display a toast notification (using the toast utility) with a user-friendly error message such as 'Failed to move task. Changes reverted.' Verify that the rollback logic restores all affected tasks to their original state. Ensure the mutation is called for both empty and non-empty list drops."
        }
      ]
    }
  ]
}